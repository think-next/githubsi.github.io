<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> Go 反射入门 | 渐行渐远</title>
  <meta name="description" content="Neojos Personal blog about everything">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="Go 反射入门" />
<meta property="og:description" content="针对文章中代码的行号，我都在试图和源码保持一致，但源码也在不停地迭代，无法做到 100% 一致，主要还是看一个参考，了解一个脉络。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://neojos.com/blog/2021/go-%E5%8F%8D%E5%B0%84%E5%85%A5%E9%97%A8/" />
<meta property="article:published_time" content="2021-04-19T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-04-19T00:00:00+00:00" />

  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go 反射入门"/>
<meta name="twitter:description" content="针对文章中代码的行号，我都在试图和源码保持一致，但源码也在不停地迭代，无法做到 100% 一致，主要还是看一个参考，了解一个脉络。"/>

  
  
    
  
  
  <link rel="stylesheet" href="https://neojos.com/css/style-white.css">
  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
<link rel="icon" type="image/png" href="https://neojos.com/images/favicon.ico" />

  
  

  <style>
    :root {
      font-size: 1em;
      --main-font: orange;
    }

    .featured {
      width: 20em;
      height: calc(6em - 16px);
      font-size: 1rem;
      border-radius: .15em;
      background-color: var(--main-font);
      box-shadow: .45em .25em #6f9090;
    }
  </style>
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="https://neojos.com/">
  
    <div id="logo" style="background-image: url(https://neojos.com/img/mifeng.jpeg)"></div>
  
  <div id="title">
    <h1>渐行渐远</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#"><i class="fas fa-bars fa-2x"></i></a>
      </li>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/blog">技术</a></li>
      
        <li><a href="/greatperson">生活</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <h1 id="title">Go 反射入门</h1>文章 942 字
  <aside>
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#indirect">Indirect</a></li>
        <li><a href="#kind">Kind</a></li>
        <li><a href="#type">Type</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </aside>
  <div class="content" itemprop="articleBody">
  
    <p>针对文章中代码的行号，我都在试图和源码保持一致，但源码也在不停地迭代，无法做到 100% 一致，主要还是看一个参考，了解一个脉络。</p>
<h3 id="indirect">Indirect</h3>
<p>通过下面的例子，我们来深入了解 <code>reflect</code> 数据包。我们定义 <code>People</code> 的结构体类型，来开始探索。</p>
<p>我们先来熟悉一下 <code>reflect.Indirect</code> 方法的使用。<code>reflect.Indirect</code> 返回的是底层的值类型，所以，下面第 12 行代码中调用 <code>Kind</code> 返回的类型为 <code>struct</code>。
而第 10 行代码输出结构体本身的 <code>Kind</code> 类型为 <code>ptr</code> 。</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="display:block;width:100%;background-color:#e5e5e5"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span></span><span style="display:block;width:100%;background-color:#e5e5e5"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span></span><span style="display:block;width:100%;background-color:#e5e5e5"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="display:block;width:100%;background-color:#e5e5e5"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span></span><span style="display:block;width:100%;background-color:#e5e5e5"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:block;width:100%;background-color:#e5e5e5"><span style="color:#00f">type</span> <span style="color:#000">People</span> <span style="color:#00f">struct</span> {
</span><span style="display:block;width:100%;background-color:#e5e5e5">    <span style="color:#000">Age</span> <span style="color:#00f">int64</span>
</span><span style="display:block;width:100%;background-color:#e5e5e5">}
</span>
<span style="color:#00f">func</span> <span style="color:#000">main</span>() {
    <span style="color:#000">p</span> := &amp;<span style="color:#000">People</span>{
        <span style="color:#000">Age</span>: <span style="color:#3af">30</span>,
    }

  	<span style="color:#000">fmt</span>.<span style="color:#000">Println</span>(<span style="color:#000">reflect</span>.<span style="color:#000">ValueOf</span>(<span style="color:#000">p</span>).<span style="color:#000">Kind</span>())		<span style="color:#888;font-style:italic">// ouput: ptr
</span><span style="display:block;width:100%;background-color:#e5e5e5"><span style="color:#888;font-style:italic"></span>    <span style="color:#000">value</span> := <span style="color:#000">reflect</span>.<span style="color:#000">Indirect</span>(<span style="color:#000">reflect</span>.<span style="color:#000">ValueOf</span>(<span style="color:#000">p</span>))
</span><span style="display:block;width:100%;background-color:#e5e5e5">  	<span style="color:#000">fmt</span>.<span style="color:#000">Println</span>(<span style="color:#000">value</span>.<span style="color:#000">Kind</span>())		<span style="color:#888;font-style:italic">// output: struct
</span></span><span style="color:#888;font-style:italic"></span>}</code></pre></td></tr></table>
</div>
</div>
<p><code>Indriect</code> 英文的含义形容词 &ldquo;间接的&rdquo;。这算的上是 <code>reflect</code> 包中比较简单的方法了。间接和直接的区别在于是否使用到指针，因为 <code>Indirect</code>
返回的是指针指向的值。如果参数本身不是指针类型，那就不需要做额外处理。</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="display:block;width:100%;background-color:#e5e5e5"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2339
</span></span><span style="display:block;width:100%;background-color:#e5e5e5"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2340
</span></span><span style="display:block;width:100%;background-color:#e5e5e5"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2341
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2342
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2343
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2344
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2345
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2346
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2347
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:block;width:100%;background-color:#e5e5e5"><span style="color:#888;font-style:italic">// Indirect returns the value that v points to.
</span></span><span style="display:block;width:100%;background-color:#e5e5e5"><span style="color:#888;font-style:italic">// If v is a nil pointer, Indirect returns a zero Value.
</span></span><span style="display:block;width:100%;background-color:#e5e5e5"><span style="color:#888;font-style:italic">// If v is not a pointer, Indirect returns v.
</span></span><span style="color:#888;font-style:italic"></span><span style="color:#00f">func</span> <span style="color:#000">Indirect</span>(<span style="color:#000">v</span> <span style="color:#000">Value</span>) <span style="color:#000">Value</span> {
	<span style="color:#00f">if</span> <span style="color:#000">v</span>.<span style="color:#000">Kind</span>() != <span style="color:#000">Ptr</span> {
		<span style="color:#00f">return</span> <span style="color:#000">v</span>
	}
	<span style="color:#00f">return</span> <span style="color:#000">v</span>.<span style="color:#000">Elem</span>()
}</code></pre></td></tr></table>
</div>
</div>
<p>在哪里会用到 <code>Indirect</code> 方法呢？主要是用来操作底层的数据结构。常见的就是结构体，如果入参是一个指针，我们只有获取到底层的结构体，才可以应用结构体的各种操作方法。
诸如，获取结构体的值、标签等。</p>
<h3 id="kind">Kind</h3>
<p>我认为它算 <code>reflect</code> 包的灵魂之一了，虽然本质上只是 <code>uint</code> 的别名，但它本身的信息却足够巨大。整个 Go 的基础数据类型都在这里了。工程代码中我们会声明各种类型的结构体，
比如示例代码中的 <code>People</code> 类型，它的 <code>Kind</code> 类型就是 <code>Struct</code>。</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="display:block;width:100%;background-color:#e5e5e5"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">230
</span></span><span style="display:block;width:100%;background-color:#e5e5e5"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">231
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">232
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">233
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">234
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">235
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">236
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">237
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">238
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">239
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">240
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">241
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">242
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">243
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">244
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">245
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">246
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">247
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">248
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">249
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">250
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">251
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">252
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">253
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">254
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">255
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">256
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">257
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">258
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">259
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">260
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">261
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">262
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="display:block;width:100%;background-color:#e5e5e5"><span style="color:#888;font-style:italic">// A Kind represents the specific kind of type that a Type represents.
</span></span><span style="display:block;width:100%;background-color:#e5e5e5"><span style="color:#888;font-style:italic">// The zero Kind is not a valid kind.
</span></span><span style="color:#888;font-style:italic"></span><span style="color:#00f">type</span> <span style="color:#000">Kind</span> <span style="color:#00f">uint</span>

<span style="color:#00f">const</span> (
	<span style="color:#000">Invalid</span> <span style="color:#000">Kind</span> = <span style="color:#00f">iota</span>
	<span style="color:#000">Bool</span>
	<span style="color:#000">Int</span>
	<span style="color:#000">Int8</span>
	<span style="color:#000">Int16</span>
	<span style="color:#000">Int32</span>
	<span style="color:#000">Int64</span>
	<span style="color:#000">Uint</span>
	<span style="color:#000">Uint8</span>
	<span style="color:#000">Uint16</span>
	<span style="color:#000">Uint32</span>
	<span style="color:#000">Uint64</span>
	<span style="color:#000">Uintptr</span>
	<span style="color:#000">Float32</span>
	<span style="color:#000">Float64</span>
	<span style="color:#000">Complex64</span>
	<span style="color:#000">Complex128</span>
	<span style="color:#000">Array</span>
	<span style="color:#000">Chan</span>
	<span style="color:#000">Func</span>
	<span style="color:#000">Interface</span>
	<span style="color:#000">Map</span>
	<span style="color:#000">Ptr</span>
	<span style="color:#000">Slice</span>
	<span style="color:#000">String</span>
	<span style="color:#000">Struct</span>
	<span style="color:#000">UnsafePointer</span>
)</code></pre></td></tr></table>
</div>
</div>
<p>知道这些有什么用呢？关键的一点，判断入参的类型，究竟是结构体、还是指针、或者别的类型。在框架类的代码中，经常有这种类型判断。简单举例说明一下：</p>
<p>本质上讲，Go 语言中不外乎这两种定义类型的方式。</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00f">type</span> <span style="color:#000">IString</span> <span style="color:#00f">string</span>
<span style="color:#00f">type</span> <span style="color:#000">YString</span> = <span style="color:#00f">string</span></code></pre></td></tr></table>
</div>
</div>
<p><code>IString</code> 算是重新声明一个新的类型，它和 <code>string</code> 必须强制转换。<code>YString</code> 是类型的一个别名，
本身和 <code>string</code> 类型就是完全相同的。项目代码中，其实存在很多像 <code>IString</code> 这样的类型，最常见的就是结构体声明。</p>
<p>如果我们直接通过安全断言的方式来判断类型的话， 势必要写很多的条件语句，而通过 <code>Kind</code> 就不需要这么麻烦。 因为自定义的类型是无限的，而底层的数据类型是有限的。</p>
<h3 id="type">Type</h3>
<p>反射的 <code>ValueOf</code> 和 <code>TypeOf</code> 函数是使用反射的入口，分别对应于接口类型的具体值和动态类型。下面的例子中，
第 5 行代码调用 <code>People</code> 对象 <code>Value</code> 的 <code>Type</code> 和第 6 行代码直接获取的 <code>Type</code> 做比较，输出值是相同的。</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="display:block;width:100%;background-color:#e5e5e5"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span></span><span style="display:block;width:100%;background-color:#e5e5e5"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">	<span style="color:#000">p</span> := &amp;<span style="color:#000">People</span>{
        <span style="color:#000">Age</span>: <span style="color:#3af">30</span>,
    }

<span style="display:block;width:100%;background-color:#e5e5e5">    <span style="color:#000">valueType</span> := <span style="color:#000">reflect</span>.<span style="color:#000">ValueOf</span>(<span style="color:#000">p</span>).<span style="color:#000">Type</span>()
</span><span style="display:block;width:100%;background-color:#e5e5e5">    <span style="color:#000">dynamicType</span> := <span style="color:#000">reflect</span>.<span style="color:#000">TypeOf</span>(<span style="color:#000">p</span>)
</span>    <span style="color:#00f">if</span> <span style="color:#000">valueType</span> == <span style="color:#000">dynamicType</span> {
      	<span style="color:#000">fmt</span>.<span style="color:#000">Println</span>(<span style="color:#5a2">&#34;equal&#34;</span>)		<span style="color:#888;font-style:italic">// output: equal
</span><span style="color:#888;font-style:italic"></span>    }</code></pre></td></tr></table>
</div>
</div>
<p>一些博客文章介绍了反射类型的转换关系，<code>Value</code>、<code>Type</code>、<code>interface</code> 三种类型之间相互转换。这个例子侧面说明了 <code>Value</code> 和 <code>Type</code> 的转换，但在源码的实现上，
通过调用 <code>Value</code> 类型的 <code>Type</code> 方法和直接使用 <code>TypeOf</code> 差别其实挺大的。</p>
<p>如果对底层的实现细节不清楚，这个转换关系其实挺让人困惑的。这究竟是一个&quot;恒等式&rdquo;，还是只针对某些具体的类型，这样的转换才成立。我其实就特别困惑，
我不仅仅是困惑 <code>Value</code> 类型到 <code>Type</code> 类型的转换，还困惑通过直接调用 <code>TypeOf</code> 获取 <code>Type</code> 和通过调用 <code>ValueOf</code> 获取 <code>Type</code> 两者的效率差异。</p>
<h4 id="typeof">TypeOf</h4>
<p><code>TypeOf</code>的逻辑比较简单，通过使用 <code>unsafe</code> 包将接口类型强转一个 <code>emptyInterface</code> 类型，然后直接返回 <code>emptyInterface</code> 类型的 <code>typ</code> 属性。</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1366
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1367
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1368
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1369
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1370
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1371
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#888;font-style:italic">// TypeOf returns the reflection Type that represents the dynamic type of i.
</span><span style="color:#888;font-style:italic">// If i is a nil interface value, TypeOf returns nil.
</span><span style="color:#888;font-style:italic"></span><span style="color:#00f">func</span> <span style="color:#000">TypeOf</span>(<span style="color:#000">i</span> <span style="color:#00f">interface</span>{}) <span style="color:#000">Type</span> {
	<span style="color:#000">eface</span> := *(*<span style="color:#000">emptyInterface</span>)(<span style="color:#000">unsafe</span>.<span style="color:#000">Pointer</span>(&amp;<span style="color:#000">i</span>))
	<span style="color:#00f">return</span> <span style="color:#000">toType</span>(<span style="color:#000">eface</span>.<span style="color:#000">typ</span>)
}</code></pre></td></tr></table>
</div>
</div>
<p><code>TypeOf</code> 函数很简单，我们只需要查看 <code>emptyInterface</code> 的类型定义，然后查看这个类型的 <code>typ</code> 属性来确认 <code>Type</code>。另一个细节就是 <code>toType</code> 方法，
也需要进去函数看一看具体的实现。</p>
<p><code>interface</code> 被大家分成两类来区分，空接口和非空接口，下面看到的就是空接口 <code>emptyInterface</code> 的类型声明。<code>typ</code> 指向具体的类型，而 <code>word</code> 指向具体值的地址。
我们也可以看出，默认将某一个具体类型转换成 <code>interface</code> 类型，系统还是做了很多转换工作的。</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">193
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">194
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">195
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">196
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">197
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#888;font-style:italic">// emptyInterface is the header for an interface{} value.
</span><span style="color:#888;font-style:italic"></span><span style="color:#00f">type</span> <span style="color:#000">emptyInterface</span> <span style="color:#00f">struct</span> {
	<span style="color:#000">typ</span>  *<span style="color:#000">rtype</span>
	<span style="color:#000">word</span> <span style="color:#000">unsafe</span>.<span style="color:#000">Pointer</span>
}</code></pre></td></tr></table>
</div>
</div>
<p>深入 <code>toType</code> 方法看一下源码实现，注释其实挺丰富的，我却只能看懂字面意思。但从功能上讲，代码的作用很简单，当入参为 <code>nil</code> 时，直接返回 <code>nil</code>。
因为返回值类型 <code>Type</code> 是一个接口类型，针对接口类型来说，返回 <code>*rtype</code> 类型的 <code>nil</code> 和 <code>nil</code> 可完全是两码事。</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2968
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2969
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2970
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2971
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2972
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2973
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2974
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2975
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2976
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2977
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2978
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#888;font-style:italic">// toType converts from a *rtype to a Type that can be returned
</span><span style="color:#888;font-style:italic">// to the client of package reflect. In gc, the only concern is that
</span><span style="color:#888;font-style:italic">// a nil *rtype must be replaced by a nil Type, but in gccgo this
</span><span style="color:#888;font-style:italic">// function takes care of ensuring that multiple *rtype for the same
</span><span style="color:#888;font-style:italic">// type are coalesced into a single Type.
</span><span style="color:#888;font-style:italic"></span><span style="color:#00f">func</span> <span style="color:#000">toType</span>(<span style="color:#000">t</span> *<span style="color:#000">rtype</span>) <span style="color:#000">Type</span> {
	<span style="color:#00f">if</span> <span style="color:#000">t</span> == <span style="color:#00f">nil</span> {
		<span style="color:#00f">return</span> <span style="color:#00f">nil</span>
	}
	<span style="color:#00f">return</span> <span style="color:#000">t</span>
}</code></pre></td></tr></table>
</div>
</div>
<h4 id="valueof">ValueOf</h4>
<p>下面是源码中 <code>Value</code>转<code>Type</code>的方法。示例代码中，方法运行到注释为<code>Easy case</code>的逻辑里就直接返回了，后续的其他逻辑并没有执行到。</p>
<p>疑问的是，<code>flagMethod</code>是如何设置到<code>v.flag</code>上的呢？</p>
<p>查看源码，通过<code>ValueOf</code>方法设置的<code>flag</code>是无法把<code>flagMethod</code>指定的<code>bit</code>位设置成1的。<code>flagMethod</code>的常量定义:<code>flagMethod      flag = 1 &lt;&lt; 9</code>，把1右移9位，在<code>reflect.ValueOf</code>中并没有做这样的逻辑处理。</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1904
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1905
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1906
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1907
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1908
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1909
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1910
</span><span style="display:block;width:100%;background-color:#e5e5e5"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1911
</span></span><span style="display:block;width:100%;background-color:#e5e5e5"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1912
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1913
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1914
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1915
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1916
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1917
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1918
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1919
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1920
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1921
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1922
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1923
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1924
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1925
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1926
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1927
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1928
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1929
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1930
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1931
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1932
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1933
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1934
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1935
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#888;font-style:italic">// Type returns v&#39;s type.
</span><span style="color:#888;font-style:italic"></span><span style="color:#00f">func</span> (<span style="color:#000">v</span> <span style="color:#000">Value</span>) <span style="color:#000">Type</span>() <span style="color:#000">Type</span> {
	<span style="color:#000">f</span> := <span style="color:#000">v</span>.<span style="color:#000">flag</span>
	<span style="color:#00f">if</span> <span style="color:#000">f</span> == <span style="color:#3af">0</span> {
		<span style="color:#000">panic</span>(&amp;<span style="color:#000">ValueError</span>{<span style="color:#5a2">&#34;reflect.Value.Type&#34;</span>, <span style="color:#000">Invalid</span>})
	}
	<span style="color:#00f">if</span> <span style="color:#000">f</span>&amp;<span style="color:#000">flagMethod</span> == <span style="color:#3af">0</span> {
<span style="display:block;width:100%;background-color:#e5e5e5">		<span style="color:#888;font-style:italic">// Easy case
</span></span><span style="display:block;width:100%;background-color:#e5e5e5"><span style="color:#888;font-style:italic"></span>		<span style="color:#00f">return</span> <span style="color:#000">v</span>.<span style="color:#000">typ</span>
</span>	}

	<span style="color:#888;font-style:italic">// Method value.
</span><span style="color:#888;font-style:italic"></span>	<span style="color:#888;font-style:italic">// v.typ describes the receiver, not the method type.
</span><span style="color:#888;font-style:italic"></span>  <span style="color:#888;font-style:italic">// 获取方法的下标
</span><span style="color:#888;font-style:italic"></span>	<span style="color:#000">i</span> := <span style="color:#000">int</span>(<span style="color:#000">v</span>.<span style="color:#000">flag</span>) &gt;&gt; <span style="color:#000">flagMethodShift</span>
	<span style="color:#00f">if</span> <span style="color:#000">v</span>.<span style="color:#000">typ</span>.<span style="color:#000">Kind</span>() == <span style="color:#000">Interface</span> {
		<span style="color:#888;font-style:italic">// Method on interface.
</span><span style="color:#888;font-style:italic"></span>		<span style="color:#000">tt</span> := (*<span style="color:#000">interfaceType</span>)(<span style="color:#000">unsafe</span>.<span style="color:#000">Pointer</span>(<span style="color:#000">v</span>.<span style="color:#000">typ</span>))
		<span style="color:#00f">if</span> <span style="color:#000">uint</span>(<span style="color:#000">i</span>) &gt;= <span style="color:#000">uint</span>(<span style="color:#000">len</span>(<span style="color:#000">tt</span>.<span style="color:#000">methods</span>)) {
			<span style="color:#000">panic</span>(<span style="color:#5a2">&#34;reflect: internal error: invalid method index&#34;</span>)
		}
		<span style="color:#000">m</span> := &amp;<span style="color:#000">tt</span>.<span style="color:#000">methods</span>[<span style="color:#000">i</span>]
		<span style="color:#00f">return</span> <span style="color:#000">v</span>.<span style="color:#000">typ</span>.<span style="color:#000">typeOff</span>(<span style="color:#000">m</span>.<span style="color:#000">typ</span>)
	}
	<span style="color:#888;font-style:italic">// Method on concrete type.
</span><span style="color:#888;font-style:italic"></span>	<span style="color:#000">ms</span> := <span style="color:#000">v</span>.<span style="color:#000">typ</span>.<span style="color:#000">exportedMethods</span>()
	<span style="color:#00f">if</span> <span style="color:#000">uint</span>(<span style="color:#000">i</span>) &gt;= <span style="color:#000">uint</span>(<span style="color:#000">len</span>(<span style="color:#000">ms</span>)) {
		<span style="color:#000">panic</span>(<span style="color:#5a2">&#34;reflect: internal error: invalid method index&#34;</span>)
	}
	<span style="color:#000">m</span> := <span style="color:#000">ms</span>[<span style="color:#000">i</span>]
	<span style="color:#00f">return</span> <span style="color:#000">v</span>.<span style="color:#000">typ</span>.<span style="color:#000">typeOff</span>(<span style="color:#000">m</span>.<span style="color:#000">mtyp</span>)
}</code></pre></td></tr></table>
</div>
</div>
<p>上述<code>Easy case</code>之后的逻辑该如何触发呢？</p>
<p>通过方法的名称，我们还是可以隐约猜测到，它可能是一个方法的 <code>Value</code>。我们给 <code>People</code>对象追加一个方法，获取方法的<code>Value</code>对象，然后通过这个对象获取<code>Type</code>。代码的调整如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">People</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">Age</span> <span style="color:#66d9ef">int64</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">People</span>) <span style="color:#a6e22e">Describe</span>() {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;people age:&#34;</span>, <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Age</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">People</span>{
        <span style="color:#a6e22e">Age</span>: <span style="color:#ae81ff">30</span>,
    }

    <span style="color:#a6e22e">methodType</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#a6e22e">p</span>).<span style="color:#a6e22e">MethodByName</span>(<span style="color:#e6db74">&#34;Describe&#34;</span>).
        <span style="color:#a6e22e">Type</span>()
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">methodType</span>)
}
</code></pre></div><p>通过断点调试，这样处理后，确实触发了<code>Easy case</code>之后的逻辑。</p>
<p>那么，<code>MethodByName</code>具体做了什么操作呢？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// MethodByName returns a function value corresponding to the method
</span><span style="color:#75715e">// of v with the given name.
</span><span style="color:#75715e">// The arguments to a Call on the returned function should not include
</span><span style="color:#75715e">// a receiver; the returned function will always use v as the receiver.
</span><span style="color:#75715e">// It returns the zero Value if no method was found.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Value</span>) <span style="color:#a6e22e">MethodByName</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>) <span style="color:#a6e22e">Value</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">typ</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		panic(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ValueError</span>{<span style="color:#e6db74">&#34;reflect.Value.MethodByName&#34;</span>, <span style="color:#a6e22e">Invalid</span>})
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">flag</span><span style="color:#f92672">&amp;</span><span style="color:#a6e22e">flagMethod</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Value</span>{}
	}
	<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">typ</span>.<span style="color:#a6e22e">MethodByName</span>(<span style="color:#a6e22e">name</span>)
	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Value</span>{}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">Method</span>(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Index</span>)
}
</code></pre></div><p>在 <code>Method</code>方法中，重新创建了返回的<code>Value</code>,并对 <code>flag</code>做好了标志位。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Method returns a function value corresponding to v&#39;s i&#39;th method.
</span><span style="color:#75715e">// The arguments to a Call on the returned function should not include
</span><span style="color:#75715e">// a receiver; the returned function will always use v as the receiver.
</span><span style="color:#75715e">// Method panics if i is out of range or if v is a nil interface value.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">v</span> <span style="color:#a6e22e">Value</span>) <span style="color:#a6e22e">Method</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">Value</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">typ</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		panic(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ValueError</span>{<span style="color:#e6db74">&#34;reflect.Value.Method&#34;</span>, <span style="color:#a6e22e">Invalid</span>})
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">flag</span><span style="color:#f92672">&amp;</span><span style="color:#a6e22e">flagMethod</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> uint(<span style="color:#a6e22e">i</span>) <span style="color:#f92672">&gt;=</span> uint(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">typ</span>.<span style="color:#a6e22e">NumMethod</span>()) {
		panic(<span style="color:#e6db74">&#34;reflect: Method index out of range&#34;</span>)
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">typ</span>.<span style="color:#a6e22e">Kind</span>() <span style="color:#f92672">==</span> <span style="color:#a6e22e">Interface</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">IsNil</span>() {
		panic(<span style="color:#e6db74">&#34;reflect: Method on nil interface value&#34;</span>)
	}
	<span style="color:#a6e22e">fl</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">flag</span>.<span style="color:#a6e22e">ro</span>() | (<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">flag</span> <span style="color:#f92672">&amp;</span> <span style="color:#a6e22e">flagIndir</span>)
	<span style="color:#a6e22e">fl</span> <span style="color:#f92672">|=</span> <span style="color:#a6e22e">flag</span>(<span style="color:#a6e22e">Func</span>)
	<span style="color:#a6e22e">fl</span> <span style="color:#f92672">|=</span> <span style="color:#a6e22e">flag</span>(<span style="color:#a6e22e">i</span>)<span style="color:#f92672">&lt;&lt;</span><span style="color:#a6e22e">flagMethodShift</span> | <span style="color:#a6e22e">flagMethod</span>
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Value</span>{<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">typ</span>, <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">ptr</span>, <span style="color:#a6e22e">fl</span>}
}
</code></pre></div>
  

    
    
  </div>
</article>


    <footer id="footer">
  <div class="footer-left">
    Copyright  &copy; 2022  渐行渐远 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">主页</a></li>
         
        <li><a href="/blog">技术</a></li>
         
        <li><a href="/greatperson">生活</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
